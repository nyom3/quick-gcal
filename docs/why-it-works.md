# なぜ動くのか？ (Why it Works)

このドキュメントは、`quick-gcal` アプリケーションがどのようにして技術的に機能しているかを解説します。

## 1. 全体アーキテクチャ

このアプリケーションは、**Next.js (App Router)** をフレームワークとして採用したシングルページアプリケーション (SPA) です。
主要な構成要素は以下の通りです。

- **フロントエンド**: React (Next.js) + Tailwind CSS + shadcn/ui
  - ユーザーインターフェースの描画と状態管理を担当します。
  - フォームからの入力を受け付け、Make Webhook へのAPIリクエストを送信します。

- **バックエンド (外部サービス)**: Make (旧 Integromat)
  - Google Calendar API との連携を担うノーコード/ローコードプラットフォームです。
  - Webhook を介してフロントエンドからのデータを受け取り、Googleカレンダーにイベントを登録します。

- **外部API**: Google Calendar API
  - 実際のカレンダーイベントの作成と管理を行います。Make を介してアクセスされます。

## 2. データフロー

ユーザーがフォームに情報を入力し、イベントを登録するまでのデータの流れは以下の通りです。

1.  **クライアント (QuickAddForm) → APIラッパー (`src/api/calendar.ts`)**
    - ユーザーが `QuickAddForm` コンポーネントでイベント情報を入力し、「Add Event」ボタンをクリックします。
    - フォームの `handleSubmit` 関数が実行され、入力されたデータ（タイトル、開始日時、終了日時、場所）が `createCalendarEvent` 関数に渡されます。
    - この際、開始日時と終了日時は、ユーザーのローカルタイムゾーンオフセットを含むISO 8601形式 (`YYYY-MM-DDTHH:MM:SS+HH:MM`) に整形されます。これは、Googleカレンダーが日時を正確に解釈するために重要です。

2.  **APIラッパー (`src/api/calendar.ts`) → Make Webhook**
    - `createCalendarEvent` 関数は `axios.post` を使用して、環境変数 `NEXT_PUBLIC_MAKE_CREATE_WEBHOOK_URL` で指定されたMake Webhook URLに、整形されたイベントデータをJSON形式で送信します。

3.  **Make Webhook → Google Calendar API**
    - Make シナリオがフロントエンドからのデータを受け取ると、設定されたGoogle Calendar API のアクション（例: イベント作成）を実行し、Googleカレンダーにイベントを登録します。

4.  **Google Calendar API → Make Webhook → APIラッパー (`src/api/calendar.ts`)**
    - Google Calendar API からイベント登録のレスポンス（イベントIDや `htmlLink` など）がMake Webhook に返されます。
    - Make Webhook はこのレスポンスをフロントエンドに返します。

5.  **APIラッパー (`src/api/calendar.ts`) → クライアント (QuickAddForm)**
    - `createCalendarEvent` 関数は Make Webhook からのレスポンスを受け取り、`QuickAddForm` コンポーネントに返します。

6.  **UIの更新 (トースト通知)**
    - `QuickAddForm` は受け取ったレスポンスから `htmlLink` を抽出し、`sonner` を使用してトースト通知を表示します。
    - `htmlLink` が存在する場合、ユーザーがGoogleカレンダーで登録されたイベントを直接確認できるように、リンク付きのメッセージが表示されます。このリンクは、Googleカレンダーがイベントを認識するまでの時間差を考慮し、2秒の遅延を設けて表示されます。

## 3. 主要な技術選択

-   **Next.js App Router**: モダンなReactの機能（Server Components等）を活用しつつ、ファイルベースのルーティングで直感的な開発を可能にするために採用しました。
-   **React**: ユーザーインターフェースを構築するための宣言的で効率的なライブラリです。
-   **Tailwind CSS**: ユーティリティファーストのアプローチにより、CSSを直接書くことなく、迅速かつ一貫性のあるUIデザインを構築できます。
-   **shadcn/ui**: Tailwind CSSをベースにした再利用可能なUIコンポーネント集です。アクセシビリティとカスタマイズ性を考慮して設計されており、開発効率を向上させます。
-   **Make (旧 Integromat)**: Google Calendar APIとの直接連携を抽象化し、ノーコードで柔軟なワークフローを構築できるため、バックエンド開発の負担を軽減します。
-   **axios**: ブラウザとNode.jsの両方で動作するPromiseベースのHTTPクライアントです。APIリクエストを簡単かつ効率的に行うために使用します。
-   **sonner**: 美しくカスタマイズ可能なトースト通知を簡単に実装できるライブラリです。

## 4. 重要な実装と課題解決

### 4.1. 日付・時刻のタイムゾーン処理

-   **課題**: フォームから取得した日付と時刻をそのままGoogleカレンダーに送信すると、タイムゾーンの解釈の違いにより、意図しない日時でイベントが登録される可能性がありました。特に `Date.prototype.toISOString()` はUTCでフォーマットするため、ローカルタイムゾーンとのズレが生じやすいです。
-   **解決策**:
    -   `src/lib/utils.ts` の `formatDate` 関数を修正し、`Date` オブジェクトのローカルの年、月、日を直接取得して `YYYY-MM-DD` 形式にフォーマットするようにしました。
    -   `src/components/QuickAddForm.tsx` の `handleSubmit` 関数内で、フォームの入力値から `Date` オブジェクトを構築し、`getTimezoneOffset()` を利用してローカルタイムゾーンのオフセット（例: `+09:00`）を計算します。
    -   このオフセットを日時文字列に付加し、ISO 8601拡張形式 (`YYYY-MM-DDTHH:MM:SS+HH:MM`) でMake Webhookに送信することで、Googleカレンダーが日時をユーザーのローカルタイムゾーンで正確に解釈できるようにしました。

### 4.2. `htmlLink` の挙動とユーザー体験の改善

-   **課題**: Google Calendar API から返される `htmlLink` は、既に登録されたイベントをGoogleカレンダーのウェブインターフェースで表示するためのリンクであり、イベントを直接追加・編集する機能はありません。そのため、イベント登録直後にこのリンクをクリックすると、Googleカレンダーがイベントをまだ認識しておらず、「予定が見つかりません」というメッセージが表示されることがありました。
-   **解決策**: もともと`htmlLink`はイベントをカレンダーに追加するものではなく、**既に登録されたイベントをGoogleカレンダーで表示する**ためのリンクです。この目的をユーザーに明確に伝えるため、トーストメッセージを「✅ 予定を登録しました (カレンダーで表示)」に変更しました。また、Googleカレンダーがイベントを認識するまでの時間差を考慮し、`htmlLink` を含むトースト通知の表示を2秒遅延させる `setTimeout` を導入しました。これにより、ユーザーがリンクをクリックした際にイベントが見つかる可能性を高め、ユーザー体験を向上させます。

### 4.3. フォームリセット時のデフォルト値の更新

-   **課題**: イベント登録後、フォームがリセットされても、日付と時刻のデフォルト値が古いままになる問題がありました。これは、`useState` の初期値がコンポーネントの初回レンダリング時に一度だけ評価されるためです。
-   **解決策**: `useState` の初期値設定で `new Date()` を直接使用するように変更し、コンポーネントがマウントされるたびに現在の日付と時刻が取得されるようにしました。フォームをリセットする際（`handleSubmit` 関数内）にも、`new Date()` を使用して新しい `Date` オブジェクトを作成し、それに基づいて各ステート（`date`, `startTime`, `endTime`）を更新するようにしました。これにより、連続してイベントを登録する際に、常に最新の日時がデフォルトとして表示されるようになります。

### 4.4. パフォーマンス最適化 (`useCallback`)

-   **課題**: Reactコンポーネントが再レンダリングされるたびに、`handleSubmit` のようなイベントハンドラー関数が再作成され、不要なパフォーマンスオーバーヘッドが発生する可能性がありました。
-   **解決策**: `handleSubmit` 関数を `useCallback` フックでラップしました。これにより、`handleSubmit` が依存するステート（`title`, `date`, `startTime`, `endTime`, `location`）が変更されない限り、関数オブジェクトが再利用されるようになり、特に子コンポーネントに渡される場合に不要な再レンダリングを防ぎ、パフォーマンスを最適化します。

### 4.5. クライアントサイドレンダリング (`"use client"`)

-   **目的**: Next.jsのApp Routerでは、デフォルトでReact Server Components (RSC) が使用され、サーバーサイドでコンポーネントがレンダリングされます。しかし、`useState` や `useCallback` といったReact Hooksや、ブラウザAPI（`setTimeout`など）を使用するインタラクティブなコンポーネントは、クライアントサイドで実行される必要があります。
-   **実装**: `src/components/QuickAddForm.tsx` の冒頭に `"use client"` ディレクティブを記述することで、このコンポーネントとその子孫コンポーネントがクライアントバンドルに含まれ、ブラウザで実行されるように明示しています。
